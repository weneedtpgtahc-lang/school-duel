<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Virus vs Vaccine Duel (Online)</title>
  <style>
    :root{
      --bg:#0e1117;
      --panel:#101826;
      --card:#ffffff;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --accent:#ff2d2d;
      --ok:#22c55e;
      --line:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;background:var(--bg);color:var(--text);}
    button,input,select{font:inherit}
    .wrap{max-width:1200px;margin:0 auto;padding:16px;}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;}
    .sp{justify-content:space-between}
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:16px;
      padding:14px;
      box-shadow:var(--shadow);
    }
    .title{font-weight:1000;font-size:20px;margin:0 0 8px;}
    .btn{
      border:1px solid var(--line);
      background:#0b1220;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
    }
    .btn.primary{background:var(--accent);border-color:rgba(0,0,0,.25);color:#fff;}
    .btn.ok{background:var(--ok);border-color:rgba(0,0,0,.25);color:#04110a;}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .input{
      background:#0b1220;color:var(--text);
      border:1px solid var(--line);
      padding:10px 12px;border-radius:12px;min-width:180px;
    }
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;border:1px solid var(--line);
      background:rgba(0,0,0,.18);font-weight:900;
    }
    .muted{color:var(--muted);font-weight:700}

    /* game layout */
    .grid2{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 980px){
      .grid2{grid-template-columns:1fr;}
    }

    .board{
      display:grid;
      grid-template-columns:1fr;
      gap:12px;
    }
    .playerBar{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    }
    .hpBox{
      display:flex;gap:10px;align-items:center;
      padding:10px 12px;border-radius:14px;border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      cursor:pointer;
      user-select:none;
    }
    .hpVal{font-weight:1000;font-size:18px}
    .manaVal{font-weight:1000}
    .turnTag{font-weight:1000}
    .who{
      font-weight:1000;
      padding:6px 10px;border-radius:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
    }

    .fieldWrap{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .slot{
      border:1px dashed rgba(255,255,255,.25);
      border-radius:14px;
      min-height:150px;
      padding:10px;
      background:rgba(0,0,0,.14);
      display:flex;flex-direction:column;gap:8px;justify-content:space-between;
    }
    .slot.locked{opacity:.45}
    .slotHead{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-weight:900}
    .mini{font-size:12px}
    .monsterCard{
      background:var(--card);
      color:#000;
      border-radius:14px;
      overflow:hidden;
      border:3px solid rgba(0,0,0,.18);
      box-shadow:0 10px 24px rgba(0,0,0,.22);
      cursor:pointer;
      user-select:none;
    }
    .monsterCard.sel{border-color:var(--accent);outline:5px solid rgba(255,45,45,.25);}
    .thumb{
      height:105px;
      display:flex;align-items:center;justify-content:center;
      background:linear-gradient(180deg,#f7fbff,#e6f4ff);
    }
    .thumb img{max-width:92%;max-height:92%;object-fit:contain}
    .meta{padding:10px 10px 12px}
    .name{font-weight:1000}
    .stats{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
    .pill{
      padding:3px 8px;border-radius:999px;font-size:12px;font-weight:1000;
      background:#f3f4f6;border:1px solid #d1d5db;color:#000;
    }
    .eff{margin-top:7px;font-size:12px;opacity:.75;line-height:1.35}
    .hand{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap:10px;
      margin-top:10px;
    }

    .side .panel{margin-bottom:12px}
    .log{
      max-height:260px;overflow:auto;
      font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:12px;
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      white-space:pre-wrap;
    }
    .danger{color:#fecaca}
    .oktext{color:#bbf7d0}
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="row sp">
      <div>
        <div class="title">Virus vs Vaccine Duel (ì˜¨ë¼ì¸)</div>
        <div class="muted">ë°© ì½”ë“œë¡œ 2ëª…ì´ ë“¤ì–´ì˜¤ë©´ ì§„ì˜ ì„ íƒ â†’ ë°©ì¥ ì‹œì‘ â†’ ê²Œì„ UI ìƒì„±</div>
      </div>
      <div class="row">
        <span class="badge" id="connBadge">ì—°ê²°: -</span>
        <span class="badge" id="roomBadge">ë°©: -</span>
        <span class="badge" id="meBadge">ë‚´ ìë¦¬: -</span>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnCreate">ë°© ë§Œë“¤ê¸°</button>
      <input class="input" id="inCode" placeholder="ì½”ë“œ ì…ë ¥ (ì˜ˆ: ABC12)" />
      <button class="btn" id="btnJoin">ì°¸ê°€</button>

      <span style="width:10px"></span>

      <select class="input" id="selFaction">
        <option value="">ì§„ì˜ ì„ íƒ</option>
        <option value="virus">ğŸ¦  ë°”ì´ëŸ¬ìŠ¤</option>
        <option value="vax">ğŸ’‰ ë°±ì‹ </option>
      </select>
      <button class="btn ok" id="btnPick" disabled>ì§„ì˜ í™•ì •</button>
      <button class="btn primary" id="btnStart" disabled>ê²Œì„ ì‹œì‘(ë°©ì¥)</button>
    </div>
  </div>

  <div id="gameRoot" style="display:none" class="grid2">
    <div class="board">
      <div class="panel">
        <div class="playerBar">
          <div class="row">
            <span class="who" id="turnWho">-</span>
            <span class="badge">í„´ <span class="turnTag" id="turnNum">-</span>/15</span>
          </div>
          <div class="row">
            <div class="hpBox" id="p1HPBox" title="(ê³µê²©í•  ë•Œ) ìƒëŒ€ HPë¥¼ í´ë¦­í•˜ë©´ ì§ì ‘ ê³µê²©">
              <span>í”Œ1 HP</span><span class="hpVal" id="p1HP">100</span>
              <span class="badge">DR <span id="p1DR">0</span>%</span>
            </div>
            <div class="hpBox" id="p2HPBox">
              <span>í”Œ2 HP</span><span class="hpVal" id="p2HP">100</span>
              <span class="badge">DR <span id="p2DR">0</span>%</span>
            </div>
          </div>
          <div class="row">
            <span class="badge">ë‚´ ë§ˆë‚˜ <span class="manaVal" id="myMana">0</span></span>
            <span class="badge">ì¹´ë“œ ì‚¬ìš© <span id="myUse">0</span>/2</span>
            <span class="badge">ê³µê²© <span id="myAtk">0</span>/2</span>
            <button class="btn" id="btnEnd" disabled>í„´ ì¢…ë£Œ</button>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="row sp">
          <div class="title" style="margin:0">í•„ë“œ</div>
          <div class="muted mini">ë‚´ í•„ë“œ 4ì¹¸ / ìƒëŒ€ í•„ë“œ 4ì¹¸ (ì£½ì€ ìŠ¬ë¡¯ì€ ë‚´ ë‹¤ìŒ í„´ê¹Œì§€ ì ê¹€)</div>
        </div>

        <div style="margin-top:10px">
          <div class="muted" style="font-weight:1000;margin-bottom:6px;">ìƒëŒ€ í•„ë“œ</div>
          <div class="fieldWrap" id="enemyField"></div>
        </div>

        <div style="margin-top:14px">
          <div class="muted" style="font-weight:1000;margin-bottom:6px;">ë‚´ í•„ë“œ</div>
          <div class="fieldWrap" id="myField"></div>
        </div>
      </div>

      <div class="panel">
        <div class="row sp">
          <div class="title" style="margin:0">ë‚´ ì†íŒ¨</div>
          <div class="muted mini">ì¹´ë“œ í´ë¦­ â†’ ë‚´ ë¹ˆ ìŠ¬ë¡¯ í´ë¦­ìœ¼ë¡œ ì†Œí™˜ / ë‚´ ëª¬ìŠ¤í„° í´ë¦­ â†’ ê³µê²© ëŒ€ìƒ í´ë¦­</div>
        </div>
        <div class="hand" id="hand"></div>
      </div>
    </div>

    <div class="side">
      <div class="panel">
        <div class="title">ìƒì </div>
        <div class="row">
          <select class="input" id="shopTier">
            <option value="low">í•˜ê¸‰ (2)</option>
            <option value="mid">ì¤‘ê¸‰ (5)</option>
            <option value="high">ìƒê¸‰ (9)</option>
          </select>
          <button class="btn ok" id="btnBuy" disabled>ëœë¤ êµ¬ë§¤(í„´ë‹¹ 1íšŒ)</button>
        </div>
        <div class="muted mini" style="margin-top:8px;">â€» êµ¬ë§¤ëŠ” ë‚´ í„´ì—ë§Œ ê°€ëŠ¥ / êµ¬ë§¤í•œ ì¹´ë“œëŠ” ì†íŒ¨ì— ì¶”ê°€</div>
      </div>

      <div class="panel">
        <div class="title">ì¡°ì‘ ìƒíƒœ</div>
        <div class="muted mini" id="modeText">-</div>
      </div>

      <div class="panel">
        <div class="title">ë¡œê·¸</div>
        <div class="log" id="log"></div>
      </div>

      <div class="panel" id="endPanel" style="display:none">
        <div class="title">ê²Œì„ ì¢…ë£Œ</div>
        <div id="endText" style="font-weight:1000"></div>
      </div>
    </div>
  </div>
</div>

<script type="module">
  // ===== Firebase (Firestore) =====
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // â˜… ì—¬ê¸°ì— ë„¤ firebaseConfig ë¶™ì—¬ë„£ê¸° â˜…
  const firebaseConfig = {
    apiKey: "PASTE_YOURS",
    authDomain: "PASTE_YOURS",
    projectId: "PASTE_YOURS",
    storageBucket: "PASTE_YOURS",
    messagingSenderId: "PASTE_YOURS",
    appId: "PASTE_YOURS",
    measurementId: "PASTE_YOURS"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // ===== Assets / Monsters =====
  // (ìŠ¤íƒ¯ì€ ë‚˜ì¤‘ì— ì¡°ì • ê°€ëŠ¥. ì§€ê¸ˆì€ â€œëŒì•„ê°€ëŠ” êµ¬ì¡°â€ ìš°ì„ )
  const virusMonsters = [
    {id:"virus_low_1", tier:"low",  name:"ì¹¨íˆ¬ í¬ì",  atk:7,  hp:16, effect:"ì—†ìŒ", img:"assets/virus/virus_low_1.png"},
    {id:"virus_low_2", tier:"low",  name:"ë³µì œ ì„¸í¬",  atk:6,  hp:18, effect:"ì—†ìŒ", img:"assets/virus/virus_low_2.png"},
    {id:"virus_low_3", tier:"low",  name:"ì ì•¡ ë¶„ì—´ì²´",atk:8,  hp:14, effect:"í”Œë ˆì´ì–´ ê³µê²© ì‹œ í‘œì‹(2í„´)", img:"assets/virus/virus_low_3.png"},
    {id:"virus_mid_1", tier:"mid",  name:"ê°ì—¼ í™•ì‚°ì²´",atk:6,  hp:32, effect:"ì—†ìŒ", img:"assets/virus/virus_mid_1.png"},
    {id:"virus_mid_2", tier:"mid",  name:"ë³€ì´ ëŒê²©ì²´",atk:11, hp:22, effect:"ì—†ìŒ", img:"assets/virus/virus_mid_2.png"},
    {id:"virus_mid_3", tier:"mid",  name:"ì€í ì ë³µì²´",atk:8,  hp:28, effect:"í”Œë ˆì´ì–´ ê³µê²© ì‹œ í‘œì‹(2í„´)", img:"assets/virus/virus_mid_3.png"},
    {id:"virus_high_1",tier:"high", name:"ìˆ™ì£¼ ì§€ë°°ì²´",atk:9,  hp:48, effect:"(ë‹¨ìˆœí™”) ì§ì ‘ ê³µê²© ì‹œ í‘œì‹(2í„´)", img:"assets/virus/virus_high_1.png"},
    {id:"virus_high_2",tier:"high", name:"ì‹ ê²½ ì˜¤ì—¼ì²´",atk:14, hp:34, effect:"í”Œë ˆì´ì–´ ê³µê²© ì‹œ í‘œì‹(2í„´)", img:"assets/virus/virus_high_2.png"},
    {id:"virus_high_3",tier:"high", name:"ì¬ì•™ êµ°ì²´í•µ",atk:10, hp:52, effect:"ì—†ìŒ", img:"assets/virus/virus_high_3.png"},
  ];

  const vaxMonsters = [
    {id:"vax_low_1", tier:"low",  name:"ì£¼ì‚¬ë³‘",     atk:6,  hp:18, effect:"ì—†ìŒ", img:"assets/vax/vax_low_1.png"},
    {id:"vax_low_2", tier:"low",  name:"ì†Œë… ìš”ì›",   atk:7,  hp:16, effect:"ì—†ìŒ", img:"assets/vax/vax_low_2.png"},
    {id:"vax_low_3", tier:"low",  name:"ë°©ì—­ ë“œë¡ ",   atk:5,  hp:20, effect:"ì—†ìŒ", img:"assets/vax/vax_low_3.png"},
    {id:"vax_mid_1", tier:"mid",  name:"í•­ì²´ ë°©íŒ¨ë³‘", atk:7,  hp:30, effect:"ì—†ìŒ", img:"assets/vax/vax_mid_1.png"},
    {id:"vax_mid_2", tier:"mid",  name:"ë©´ì—­ ìˆ˜í˜¸ì", atk:10, hp:24, effect:"ì—†ìŒ", img:"assets/vax/vax_mid_2.png"},
    {id:"vax_mid_3", tier:"mid",  name:"ì •í™” ê³µë³‘",   atk:9,  hp:26, effect:"ì—†ìŒ", img:"assets/vax/vax_mid_3.png"},
    {id:"vax_high_1",tier:"high", name:"ë©´ì—­ ì‚¬ë ¹ê´€", atk:12, hp:44, effect:"ì—†ìŒ", img:"assets/vax/vax_high_1.png"},
    {id:"vax_high_2",tier:"high", name:"ë°±ì‹  ë°°ì–‘ì²´", atk:9,  hp:52, effect:"ì—†ìŒ", img:"assets/vax/vax_high_2.png"},
    {id:"vax_high_3",tier:"high", name:"í•­ì› ì œì••ê¸°", atk:14, hp:40, effect:"ì—†ìŒ", img:"assets/vax/vax_high_3.png"},
  ];

  const COST = { low:2, mid:5, high:9 };

  // ===== UI helpers =====
  const $ = (id)=>document.getElementById(id);
  const logEl = $("log");
  function log(msg, kind=""){
    const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
    logEl.textContent += line;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function genCode(){
    const chars="ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let s="";
    for(let i=0;i<5;i++) s+=chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  // ===== Room / identity =====
  let roomCode = null;
  let roomRef = null;
  let unsub = null;

  // local identity per browser
  const myId = (() => {
    const k="vvv_id";
    let v=localStorage.getItem(k);
    if(!v){ v = crypto.randomUUID(); localStorage.setItem(k,v); }
    return v;
  })();
  let mySeat = null; // 0 or 1
  let lastState = null;

  function setConn(text){ $("connBadge").textContent = `ì—°ê²°: ${text}`; }
  function setRoom(text){ $("roomBadge").textContent = `ë°©: ${text}`; }
  function setMe(text){ $("meBadge").textContent = `ë‚´ ìë¦¬: ${text}`; }

  function canStart(state){
    if(!state) return false;
    const hostOk = state.hostId === myId;
    const both = state.players?.length === 2 &&
                 state.players[0]?.faction && state.players[1]?.faction;
    return hostOk && both && state.phase === "lobby";
  }

  function myTurn(state){
    return state.phase==="playing" && state.turnPlayer === mySeat;
  }

  function getPlayer(state, seat){ return state.players[seat]; }
  function enemySeat(){ return mySeat===0?1:0; }

  function playerDR(state, seat){
    const p = getPlayer(state, seat);
    const fieldCount = p.field.filter(s=>!!s.monster).length;
    const base = (p.faction==="vax") ? 20 : 0;
    const fromField = fieldCount * 20;
    return Math.min(80, base + fromField); // ìº¡ (ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šê²Œ)
  }

  function applyPlayerDamage(state, targetSeat, raw, sourceText){
    const dr = playerDR(state, targetSeat);
    const dmg = Math.max(0, Math.round(raw * (1 - dr/100)));
    state.players[targetSeat].hp -= dmg;
    log(`${sourceText} â†’ í”Œë ˆì´ì–´${targetSeat+1} í”¼í•´ ${dmg} (DR ${dr}%)`);
  }

  function checkEnd(state){
    const p1=state.players[0].hp, p2=state.players[1].hp;
    if(p1<=0 || p2<=0){
      state.phase="ended";
      state.winner = (p1===p2) ? "draw" : (p1>p2?0:1);
      return;
    }
    if(state.turn > 15){
      state.phase="ended";
      state.winner = (p1===p2) ? "draw" : (p1>p2?0:1);
      return;
    }
  }

  // ===== Create / Join =====
  async function createRoom(){
    const code = genCode();
    roomCode = code;
    roomRef = doc(db, "rooms", code);

    const init = {
      code,
      phase:"lobby", // lobby -> playing -> ended
      hostId: myId,
      createdAt: serverTimestamp(),
      turn: 0,
      turnPlayer: 0,
      players: [
        { id:null, faction:null, hp:100, mana:0, hand:[], field: makeField(), usedThisTurn:0, attackedThisTurn:0, boughtThisTurn:false, mark:0 },
        { id:null, faction:null, hp:100, mana:0, hand:[], field: makeField(), usedThisTurn:0, attackedThisTurn:0, boughtThisTurn:false, mark:0 },
      ],
      logSeed: 0
    };

    await setDoc(roomRef, init);
    setRoom(code);
    log(`ë°© ìƒì„±: ${code}`);
    await joinRoom(code);
  }

  async function joinRoom(code){
    roomCode = code.toUpperCase();
    roomRef = doc(db, "rooms", roomCode);

    const snap = await getDoc(roomRef);
    if(!snap.exists()){
      alert("ë°©ì´ ì—†ì–´!");
      return;
    }

    const state = snap.data();
    const seats = state.players;

    // find seat: already joined?
    let seat = seats.findIndex(p=>p.id===myId);
    if(seat === -1){
      seat = seats.findIndex(p=>!p.id);
      if(seat === -1){
        alert("ë°©ì´ ê½‰ ì°¼ì–´(2ëª…)");
        return;
      }
      seats[seat].id = myId;
      await updateDoc(roomRef, { players: seats });
    }

    mySeat = seat;
    setRoom(roomCode);
    setMe(`í”Œë ˆì´ì–´${mySeat+1}`);
    log(`ì°¸ê°€ ì™„ë£Œ: í”Œë ˆì´ì–´${mySeat+1}`);

    // subscribe
    if(unsub) unsub();
    unsub = onSnapshot(roomRef, (docSnap)=>{
      const s = docSnap.data();
      lastState = s;
      renderAll(s);
    });

    $("btnPick").disabled = false;
    setConn("OK");
  }

  function makeField(){
    // 4 slots, each can be lockedUntilTurn (number)
    return Array.from({length:4}, ()=>({ monster:null, lockedUntilTurn:0 }));
  }

  // ===== Faction pick & Start =====
  async function pickFaction(){
    if(!roomRef || mySeat===null) return;
    const f = $("selFaction").value;
    if(!f){ alert("ì§„ì˜ ì„ íƒí•´"); return; }
    const s = structuredClone(lastState);
    s.players[mySeat].faction = f;
    await updateDoc(roomRef, { players: s.players });
    log(`ì§„ì˜ í™•ì •: ${f==="virus"?"ë°”ì´ëŸ¬ìŠ¤":"ë°±ì‹ "}`);
  }

  async function startGame(){
    const s = structuredClone(lastState);
    if(!canStart(s)){ alert("ë‘ ëª… ëª¨ë‘ ì§„ì˜ ì„ íƒ í›„ ë°©ì¥ë§Œ ì‹œì‘ ê°€ëŠ¥"); return; }

    s.phase = "playing";
    s.turn = 1;
    s.turnPlayer = 0; // ëœë¤ ì„ ê³µ
    // ëœë¤ ì„ ê³µ
    s.turnPlayer = (Math.random()<0.5)?0:1;

    // reset stats
    for(let i=0;i<2;i++){
      s.players[i].hp = 100;
      s.players[i].mana = 0;
      s.players[i].hand = [];
      s.players[i].field = makeField();
      s.players[i].usedThisTurn = 0;
      s.players[i].attackedThisTurn = 0;
      s.players[i].boughtThisTurn = false;
      s.players[i].mark = 0;
    }

    // start turn grant mana + unlock slots if needed handled in beginTurn
    beginTurn(s);

    await updateDoc(roomRef, {
      phase:s.phase, turn:s.turn, turnPlayer:s.turnPlayer, players:s.players
    });
    log("ê²Œì„ ì‹œì‘!");
  }

  function beginTurn(state){
    const seat = state.turnPlayer;
    const p = state.players[seat];

    // decrement mark on current player at their turn start? (í‘œì‹ ì§€ì† í„´)
    if(p.mark > 0) p.mark -= 1;

    // unlock slots whose lockedUntilTurn <= current turn
    for(const slot of p.field){
      if(slot.lockedUntilTurn && slot.lockedUntilTurn <= state.turn){
        slot.lockedUntilTurn = 0;
      }
    }

    p.mana += 3;
    p.usedThisTurn = 0;
    p.attackedThisTurn = 0;
    p.boughtThisTurn = false;
  }

  async function endTurn(){
    if(!myTurn(lastState)) return;
    const s = structuredClone(lastState);

    // check end conditions first
    checkEnd(s);
    if(s.phase==="ended"){
      await updateDoc(roomRef, { phase:s.phase, winner:s.winner, players:s.players });
      return;
    }

    // next turn
    s.turn += 1;
    s.turnPlayer = (s.turnPlayer===0)?1:0;
    beginTurn(s);
    checkEnd(s);

    await updateDoc(roomRef, { turn:s.turn, turnPlayer:s.turnPlayer, phase:s.phase, winner:s.winner ?? null, players:s.players });
    log(`í„´ ì¢…ë£Œ â†’ ë‹¤ìŒ í„´: í”Œë ˆì´ì–´${s.turnPlayer+1}`);
  }

  // ===== Shop / Play / Attack state machine (UI) =====
  let selectedHandIdx = null;
  let selectedMySlot = null;
  let selectedAttackerSlot = null;
  let attackedThisTurnBy = new Set();

  function resetLocalSelections(){
    selectedHandIdx = null;
    selectedMySlot = null;
    selectedAttackerSlot = null;
    attackedThisTurnBy = new Set();
    updateModeText();
  }

  function updateModeText(){
    let t = "";
    if(selectedHandIdx!==null) t = "ì¹´ë“œ ì„ íƒë¨ â†’ ë‚´ ë¹ˆ ìŠ¬ë¡¯ í´ë¦­ìœ¼ë¡œ ì†Œí™˜";
    else if(selectedAttackerSlot!==null) t = "ê³µê²©ì ì„ íƒë¨ â†’ ìƒëŒ€ ëª¬ìŠ¤í„°/ìƒëŒ€ HP í´ë¦­";
    else t = "ëŒ€ê¸°: ì†íŒ¨ í´ë¦­(ì†Œí™˜) ë˜ëŠ” ë‚´ ëª¬ìŠ¤í„° í´ë¦­(ê³µê²©)";
    $("modeText").textContent = t;
  }

  function getPool(faction, tier){
    const pool = (faction==="virus") ? virusMonsters : vaxMonsters;
    return pool.filter(m=>m.tier===tier);
  }

  async function buyCard(){
    if(!myTurn(lastState)) return;
    const s = structuredClone(lastState);
    const me = s.players[mySeat];

    if(me.boughtThisTurn){ alert("ì´ë²ˆ í„´ì—” ì´ë¯¸ êµ¬ë§¤í–ˆì–´"); return; }

    const tier = $("shopTier").value;
    const cost = COST[tier];
    if(me.mana < cost){ alert("ë§ˆë‚˜ ë¶€ì¡±"); return; }

    const pool = getPool(me.faction, tier);
    const pick = pool[Math.floor(Math.random()*pool.length)];
    me.mana -= cost;
    me.hand.push({
      refId: pick.id,
      name: pick.name,
      tier: pick.tier,
      atk: pick.atk,
      hp: pick.hp,
      maxHp: pick.hp,
      effect: pick.effect,
      img: pick.img
    });
    me.boughtThisTurn = true;

    await updateDoc(roomRef, { players: s.players });
    log(`êµ¬ë§¤: ${tier.toUpperCase()} 1ì¥ (${cost}) â†’ ${pick.name}`);
  }

  async function playToSlot(slotIdx){
    if(!myTurn(lastState)) return;
    if(selectedHandIdx===null) return;

    const s = structuredClone(lastState);
    const me = s.players[mySeat];
    if(me.usedThisTurn >= 2){ alert("ì´ë²ˆ í„´ ì¹´ë“œ ì‚¬ìš© 2ì¥ ë"); return; }

    const slot = me.field[slotIdx];
    if(slot.lockedUntilTurn && slot.lockedUntilTurn > s.turn){ alert("ì´ ìŠ¬ë¡¯ì€ ì ê¹€"); return; }
    if(slot.monster){ alert("ì´ë¯¸ ëª¬ìŠ¤í„° ìˆìŒ"); return; }

    const card = me.hand[selectedHandIdx];
    // place monster
    slot.monster = {
      ...card,
      curHp: card.hp,
      owner: mySeat
    };
    // remove from hand
    me.hand.splice(selectedHandIdx, 1);
    me.usedThisTurn += 1;

    selectedHandIdx = null;
    await updateDoc(roomRef, { players: s.players });
    log(`ì†Œí™˜: ìŠ¬ë¡¯${slotIdx+1} â† ${slot.monster.name}`);
  }

  async function chooseAttacker(slotIdx){
    if(!myTurn(lastState)) return;
    const me = lastState.players[mySeat];
    const slot = me.field[slotIdx];
    if(!slot.monster){ return; }
    if(me.attackedThisTurn >= 2){ alert("ì´ë²ˆ í„´ ê³µê²© 2íšŒ ë"); return; }
    if(attackedThisTurnBy.has(slotIdx)){ alert("ì´ ëª¬ìŠ¤í„°ëŠ” ì´ë¯¸ ê³µê²©í•¨"); return; }
    selectedAttackerSlot = slotIdx;
    selectedHandIdx = null;
    updateModeText();
  }

  function rawDamageWithMark(state, attacker, raw){
    // í‘œì‹: "ë°›ëŠ” í”¼í•´ +20%" (ë‹¨ìˆœ/ê°€ì‹œì )
    // markëŠ” "í”Œë ˆì´ì–´ì—ê²Œ" ë¶™ëŠ”ë‹¤.
    const enemy = state.players[enemySeat()];
    const marked = enemy.mark > 0;
    return marked ? Math.round(raw * 1.2) : raw;
  }

  async function attackTarget(kind, idx){
    if(!myTurn(lastState)) return;
    if(selectedAttackerSlot===null) return;

    const s = structuredClone(lastState);
    const me = s.players[mySeat];
    const en = s.players[enemySeat()];

    if(me.attackedThisTurn >= 2){ alert("ì´ë²ˆ í„´ ê³µê²© 2íšŒ ë"); return; }
    if(attackedThisTurnBy.has(selectedAttackerSlot)){ alert("ì´ ëª¬ìŠ¤í„°ëŠ” ì´ë¯¸ ê³µê²©í•¨"); return; }

    const aSlot = me.field[selectedAttackerSlot];
    if(!aSlot.monster){ selectedAttackerSlot=null; updateModeText(); return; }
    const atk = aSlot.monster.atk;

    if(kind==="enemySlot"){
      const tSlot = en.field[idx];
      if(!tSlot.monster){ alert("ëŒ€ìƒ ëª¬ìŠ¤í„° ì—†ìŒ"); return; }
      tSlot.monster.curHp -= atk;
      log(`${aSlot.monster.name} â†’ ìƒëŒ€ ëª¬ìŠ¤í„°(${tSlot.monster.name}) ${atk} í”¼í•´`);

      // death
      if(tSlot.monster.curHp <= 0){
        log(`ì²˜ì¹˜: ${tSlot.monster.name}`);
        tSlot.monster = null;
        // lock until enemy's next turn start => when enemy turn begins, their state.turn will be (current turn + 1 if they are next, else +2)
        // simplest: lock until (s.turn + 2) always on owner's field, but more accurate:
        // if enemy is next player: their next turn is s.turn+1; else s.turn+2. Since turns alternate, enemy next turn is s.turn+1.
        tSlot.lockedUntilTurn = s.turn + 1; // enemy's next turn number
      }
    }

    if(kind==="enemyPlayer"){
      let raw = atk;
      // mark bonus
      raw = rawDamageWithMark(s, aSlot.monster, raw);
      applyPlayerDamage(s, enemySeat(), raw, `${aSlot.monster.name} ì§ì ‘ ê³µê²©`);

      // virus mark on direct attack if monster has that text
      const hasMark = (aSlot.monster.effect || "").includes("í‘œì‹");
      if(hasMark && me.faction==="virus"){
        en.mark = 2; // 2í„´ ì§€ì†
        log(`í‘œì‹ ë¶€ì—¬(2í„´): í”Œë ˆì´ì–´${enemySeat()+1}`);
      }
    }

    me.attackedThisTurn += 1;
    attackedThisTurnBy.add(selectedAttackerSlot);
    selectedAttackerSlot = null;
    updateModeText();

    checkEnd(s);
    await updateDoc(roomRef, { players: s.players, phase:s.phase, winner:s.winner ?? null });
  }

  // ===== Render =====
  function renderAll(state){
    // lobby controls
    $("btnStart").disabled = !canStart(state);
    $("btnPick").disabled = !(roomRef && mySeat!==null);

    // show game only when playing/ended
    const showGame = (state.phase==="playing" || state.phase==="ended");
    $("gameRoot").style.display = showGame ? "grid" : "none";

    setRoom(state.code || roomCode || "-");

    if(!showGame){
      $("btnBuy").disabled = true;
      $("btnEnd").disabled = true;
      return;
    }

    // top info
    $("turnNum").textContent = String(state.turn);
    $("turnWho").textContent = (state.turnPlayer===0?"í”Œë ˆì´ì–´1":"í”Œë ˆì´ì–´2") + " í„´";
    $("p1HP").textContent = state.players[0].hp;
    $("p2HP").textContent = state.players[1].hp;

    $("p1DR").textContent = String(playerDR(state,0));
    $("p2DR").textContent = String(playerDR(state,1));

    const me = state.players[mySeat];
    $("myMana").textContent = String(me.mana);
    $("myUse").textContent = String(me.usedThisTurn);
    $("myAtk").textContent = String(me.attackedThisTurn);

    $("btnBuy").disabled = !myTurn(state) || me.boughtThisTurn;
    $("btnEnd").disabled = !myTurn(state);

    // end panel
    if(state.phase==="ended"){
      $("endPanel").style.display = "block";
      const w = state.winner;
      $("endText").textContent =
        (w==="draw") ? "ë¬´ìŠ¹ë¶€" : (w===mySeat ? "ìŠ¹ë¦¬!" : "íŒ¨ë°°...");
    } else {
      $("endPanel").style.display = "none";
    }

    // fields
    renderField(state);
    renderHand(state);

    // click targets for direct attack
    // (ë‚´ í„´ì¼ ë•Œë§Œ ì‘ë™)
    $("p1HPBox").onclick = ()=>{
      if(!myTurn(state)) return;
      if(selectedAttackerSlot===null) return;
      // if p1 is enemy?
      const targetSeat = 0;
      if(targetSeat === enemySeat()) attackTarget("enemyPlayer");
    };
    $("p2HPBox").onclick = ()=>{
      if(!myTurn(state)) return;
      if(selectedAttackerSlot===null) return;
      const targetSeat = 1;
      if(targetSeat === enemySeat()) attackTarget("enemyPlayer");
    };

    // ensure mode text
    updateModeText();
  }

  function slotHTML(slot, label, clickable){
    const locked = slot.lockedUntilTurn && lastState && lastState.turn < slot.lockedUntilTurn;
    const cls = "slot" + (locked ? " locked" : "");
    const head = `
      <div class="slotHead">
        <span>${label}</span>
        <span class="mini">${locked ? `ì ê¹€(~${slot.lockedUntilTurn})` : (slot.monster?"ì „íˆ¬ì¤‘":"ë¹ˆì¹¸")}</span>
      </div>
    `;

    if(!slot.monster){
      return `<div class="${cls}" data-empty="${clickable?1:0}">${head}<div class="muted mini">${clickable? "ì—¬ê¸°ë¥¼ í´ë¦­í•˜ë©´ ì†Œí™˜" : ""}</div></div>`;
    }

    const m = slot.monster;
    return `
      <div class="${cls}" data-has="1">
        ${head}
        <div class="monsterCard" data-monster="1">
          <div class="thumb">
            <img src="${m.img}" alt="${m.name}" onerror="this.style.display='none'; this.parentNode.textContent='(ì´ë¯¸ì§€ ì—†ìŒ)';">
          </div>
          <div class="meta">
            <div class="name">${m.name}</div>
            <div class="stats">
              <span class="pill">âš” ${m.atk}</span>
              <span class="pill">â¤ ${m.curHp}</span>
              <span class="pill">${m.tier.toUpperCase()}</span>
            </div>
            <div class="eff">${m.effect || "ì—†ìŒ"}</div>
          </div>
        </div>
      </div>
    `;
  }

  function renderField(state){
    const me = state.players[mySeat];
    const en = state.players[enemySeat()];

    const myField = $("myField");
    const enemyField = $("enemyField");

    myField.innerHTML = me.field.map((s,i)=>slotHTML(s, `ë‚´ ìŠ¬ë¡¯ ${i+1}`, true)).join("");
    enemyField.innerHTML = en.field.map((s,i)=>slotHTML(s, `ìƒëŒ€ ìŠ¬ë¡¯ ${i+1}`, false)).join("");

    // bind my slots
    [...myField.children].forEach((slotEl, idx)=>{
      slotEl.onclick = ()=>{
        if(!myTurn(lastState)) return;

        // if hand selected -> summon
        if(selectedHandIdx!==null){
          playToSlot(idx);
          return;
        }
        // if monster exists -> choose attacker
        const s = lastState.players[mySeat].field[idx];
        if(s.monster){
          chooseAttacker(idx);
          // UI highlight is done by rerender on snapshot
        }
      };

      // highlight attacker
      const isAtt = (selectedAttackerSlot===idx);
      const card = slotEl.querySelector(".monsterCard");
      if(card && isAtt) card.classList.add("sel");
    });

    // bind enemy targets
    [...enemyField.children].forEach((slotEl, idx)=>{
      slotEl.onclick = ()=>{
        if(!myTurn(lastState)) return;
        if(selectedAttackerSlot===null) return;
        attackTarget("enemySlot", idx);
      };
    });
  }

  function renderHand(state){
    const handEl = $("hand");
    const me = state.players[mySeat];

    handEl.innerHTML = me.hand.map((c,idx)=>`
      <div class="monsterCard ${selectedHandIdx===idx?"sel":""}" data-hand="${idx}">
        <div class="thumb">
          <img src="${c.img}" alt="${c.name}" onerror="this.style.display='none'; this.parentNode.textContent='(ì´ë¯¸ì§€ ì—†ìŒ)';">
        </div>
        <div class="meta">
          <div class="name">${c.name}</div>
          <div class="stats">
            <span class="pill">âš” ${c.atk}</span>
            <span class="pill">â¤ ${c.hp}</span>
            <span class="pill">${c.tier.toUpperCase()}</span>
          </div>
          <div class="eff">${c.effect || "ì—†ìŒ"}</div>
        </div>
      </div>
    `).join("");

    // bind click
    [...handEl.children].forEach((el)=>{
      el.onclick = ()=>{
        if(!myTurn(lastState)) return;
        const idx = Number(el.getAttribute("data-hand"));
        selectedHandIdx = (selectedHandIdx===idx) ? null : idx;
        selectedAttackerSlot = null;
        updateModeText();
        renderAll(lastState);
      };
    });
  }

  // ===== Buttons =====
  $("btnCreate").onclick = ()=>createRoom();
  $("btnJoin").onclick = ()=>joinRoom($("inCode").value.trim());
  $("btnPick").onclick = ()=>pickFaction();
  $("btnStart").onclick = ()=>startGame();
  $("btnBuy").onclick = ()=>buyCard();
  $("btnEnd").onclick = ()=>endTurn();

  setConn("ëŒ€ê¸°");
  setRoom("-");
  setMe("-");
  updateModeText();

  // enable start button reactively
  // (onSnapshotì—ì„œ renderAllì´ í•´ì¤Œ)
</script>
</body>
</html>
