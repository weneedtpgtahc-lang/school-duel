<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "여기",
  authDomain: "여기",
  projectId: "여기",
  storageBucket: "여기",
  messagingSenderId: "여기",
  appId: "여기",
  measurementId: "여기(있으면)"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const $ = (id) => document.getElementById(id);

const me = crypto.randomUUID();
let room = null;
let unsub = null;

/* ✅ 임시 몬스터 풀(비용=하급2/중급5/상급9) */
const MONSTERS = [
  { id:"v_low_1", name:"바이러스: 침투체", faction:"virus", tier:"low",  cost:2, atk:8,  hp:18, mark:false },
  { id:"v_mid_1", name:"바이러스: 감염 확산체", faction:"virus", tier:"mid",  cost:5, atk:10, hp:26, mark:true  },
  { id:"v_high_1",name:"바이러스: 숙주 지배체", faction:"virus", tier:"high", cost:9, atk:14, hp:40, mark:true  },

  { id:"c_low_1", name:"백신: 주사병",     faction:"vaccine", tier:"low",  cost:2, atk:7,  hp:20 },
  { id:"c_mid_1", name:"백신: 항체 방패병", faction:"vaccine", tier:"mid",  cost:5, atk:9,  hp:30 },
  { id:"c_high_1",name:"백신: 면역 사령관", faction:"vaccine", tier:"high", cost:9, atk:13, hp:42 },
];

function uid(){ return Math.random().toString(36).slice(2,10); }

function listen(){
  if (!room) return;
  if (unsub) unsub();

  unsub = onSnapshot(doc(db, "rooms", room), (snap) => {
    if (!snap.exists()) { $("state").textContent = "방이 없음"; return; }
    const d = snap.data();
    $("state").textContent = JSON.stringify(d, null, 2);

    // 내 진영 기준으로 소환 리스트 갱신
    const my = d.players?.[me];
    if (my?.faction) renderMonsterSelect(my.faction);
  }, (err) => {
    $("state").textContent = "에러: " + err.message;
  });
}

function renderMonsterSelect(faction){
  const sel = $("monster");
  if (!sel) return;
  sel.innerHTML = "";
  MONSTERS.filter(m => m.faction === faction).forEach(m=>{
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = `${m.name} (코스트${m.cost}, ${m.atk}/${m.hp})`;
    sel.appendChild(opt);
  });
}

async function loadRoom(){
  if (!room) throw new Error("방 코드 없음");
  const ref = doc(db, "rooms", room);
  const snap = await getDoc(ref);
  if (!snap.exists()) throw new Error("방이 없음");
  return { ref, data: snap.data() };
}

function countAliveMonsters(field){
  return (field||[]).filter(x=>x && x.alive!==false).length;
}

/* ✅ 방 만들기 */
$("create").onclick = async () => {
  room = Math.random().toString(36).slice(2, 8).toUpperCase();

  await setDoc(doc(db, "rooms", room), {
    status: "lobby",
    turn: 1,
    turnOwner: null,
    actionLeft: 2,
    atkLeft: {},           // 몬스터별 남은 공격(나중용)
    players: {},
    lock: {},              // "pid-slot": unlockTurn
    createdAt: serverTimestamp()
  });

  $("code").value = room;
  $("info").textContent = "방: " + room;
  listen();
};

/* ✅ 방 참가 */
$("join").onclick = () => {
  room = $("code").value.trim().toUpperCase();
  $("info").textContent = "방: " + room;
  listen();
};

/* ✅ 진영 선택 + 2명 모이면 선공 랜덤 지정 */
async function chooseFaction(faction){
  const { ref, data } = await loadRoom();
  data.players = data.players || {};

  data.players[me] = {
    faction,
    hp: 100,
    mana: 0,
    field: [null,null,null,null]
  };

  if (Object.keys(data.players).length >= 2) {
    data.status = "playing";
    const pids = Object.keys(data.players);
    if (!data.turnOwner) data.turnOwner = pids[Math.floor(Math.random()*pids.length)];
  }

  await setDoc(ref, data);
}

$("virus").onclick = ()=>chooseFaction("virus");
$("vaccine").onclick = ()=>chooseFaction("vaccine");

/* ✅ 소환 */
$("summon").onclick = async ()=>{
  const { ref, data } = await loadRoom();
  if (data.status !== "playing") return alert("아직 게임 시작 전");
  if (data.turnOwner !== me) return alert("내 턴 아님");
  if ((data.actionLeft ?? 0) <= 0) return alert("이번 턴 행동 다 씀");

  const p = data.players?.[me];
  if (!p) return alert("플레이어 정보 없음");

  const slot = Number($("slot").value);
  const lockKey = `${me}-${slot}`;
  const unlockTurn = data.lock?.[lockKey] ?? 0;
  if (unlockTurn > (data.turn ?? 1)) return alert("이 칸은 잠겨있음(다음 내 턴까지)");

  if (p.field?.[slot]) return alert("이미 몬스터 있음");

  const mid = $("monster").value;
  const base = MONSTERS.find(m=>m.id===mid);
  if (!base) return alert("몬스터 선택 오류");

  if ((p.mana ?? 0) < base.cost) return alert("마나 부족");

  // 배치
  const instId = uid();
  const monsterObj = {
    instId,
    id: base.id,
    name: base.name,
    tier: base.tier,
    cost: base.cost,
    atk: base.atk,
    hp: base.hp,
    alive: true,
    mark: !!base.mark
  };

  p.mana -= base.cost;
  p.field[slot] = monsterObj;

  data.players[me] = p;
  data.actionLeft -= 1;

  // (옵션) 몬스터별 남은 공격 2회
  data.atkLeft = data.atkLeft || {};
  data.atkLeft[instId] = 2;

  await setDoc(ref, data);
};

/* ✅ 턴 종료: 마나+3, 행동 2회 리셋, 턴넘김, (락 해제는 unlockTurn 방식이라 자동) */
$("end").onclick = async ()=>{
  const { ref, data } = await loadRoom();
  if (data.status !== "playing") return alert("게임 중 아님");
  if (data.turnOwner !== me) return alert("내 턴 아님");

  const pids = Object.keys(data.players || {});
  const other = pids.find(pid => pid !== me);
  if (!other) return alert("상대 없음");

  // 다음 턴
  data.turn = (data.turn ?? 1) + 1;
  data.turnOwner = other;
  data.actionLeft = 2;

  // 다음 턴 소유자에게 마나 +3
  data.players[other].mana = (data.players[other].mana ?? 0) + 3;

  // (선택) 매 턴 atkLeft 리셋: 다음 턴 플레이어의 몬스터들만 2회로
  const f = data.players[other].field || [];
  data.atkLeft = data.atkLeft || {};
  for (const m of f) if (m?.instId) data.atkLeft[m.instId] = 2;

  // 턴 제한(15턴) 초과 처리: hp 비교로 종료
  if (data.turn > 15) {
    data.status = "end";
    const hpA = data.players[pids[0]].hp ?? 0;
    const hpB = data.players[pids[1]].hp ?? 0;
    data.winner = hpA===hpB ? "draw" : (hpA>hpB ? pids[0] : pids[1]);
  }

  await setDoc(ref, data);
};
</script>
